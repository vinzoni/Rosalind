#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Jul 14 17:21:18 2024

@author: vinzoni
"""

from dna_toolkit import *
import time
import random
import requests

def dna(inputs):
    ''' Ex. 1: counting DNA Nucleotides '''
    dnaString = inputs[0]
    a = c = g = t = 0;
    
    for nuc in dnaString:
        if nuc == 'A':
            a += 1
        elif nuc == 'C':
            c += 1
        elif nuc == 'G':
            g += 1
        elif nuc == 'T':
            t += 1
        
    return f'{a} {c} {g} {t}';
    
def rna(inputs):
    ''' Ex. 2: Transcribing DNA to RNA '''
    dnaString = inputs[0]
    return dna_to_rna_transcription(dnaString)

def revc(inputs):
    ''' Ex. 3: Complementing a strand of DNA and Reverting '''
    dnaString = inputs[0]
    return reverse_complement(dnaString)

def fib(inputs):
    ''' Ex. 4: Rabbits and Recurrence Relations '''
    n = inputs[0]
    k = inputs[1]

    f1 = f2 = 1
    for c in range(n-2):
        litters = f1 * k
        f1 = f2
        f2 = f2 + litters
    return f2

def fibd(inputs):
    ''' Ex. 5: Mortal Fibonacci Rabbits '''

    n = inputs[0]
    m = inputs[1]

    pairs = [0] * n
    newborns = [0] * n
    pairs[0] = pairs[1] = 1
    newborns[0] = 1
    newborns[1] = 0
    for idx in range(2, n):
        if idx - m >= 0:
            deaths = newborns[idx - m]
        else:
            deaths = 0
        offsprings = pairs[idx-1] - newborns[idx-1]
        pairs[idx] = pairs[idx-1] + offsprings - deaths
        newborns[idx] = pairs[idx] + deaths - pairs[idx-1]
        
    return pairs[n-1]

def gc(inputs):
    ''' Ex. 6: Computing GC Content '''
    filename = inputs[0]
    lines = open(filename, "r").read().splitlines()
    genome_dict = {}
    current_id = ""
    current_genome = ""
    for l in lines:
        if l[0] == ">":
            if len(current_genome) > 0:
                (fast_id, data, score) = (current_id, current_genome, gc_content(current_genome))
                genome_dict[fast_id] = (data, score)
            current_id = l[1:]
            current_genome = ""
        else:
            current_genome += l
    (fast_id, data, score) = (current_id, current_genome, gc_content(current_genome))
    genome_dict[fast_id] = (data, score)
    
            
    max_score = 0
    winning_id = ""
    for k, v in genome_dict.items():
        if v[1] > max_score:
            winning_id = k
            max_score = v[1]
    
    return winning_id + "\n" + str(max_score);

def hamm(inputs):
    ''' Ex. 7: Counting Point Mutations '''
    
    dna1 = inputs[0]
    dna2 = inputs[1]

    point_mutations = 0
    for a, b in zip(dna1, dna2):
        if a != b:
            point_mutations += 1
    return point_mutations

def iprb(inputs):
    ''' Ex. 8: Mendle's First Law '''
    
    k = inputs[0]
    m = inputs[1]
    n = inputs[2]
    total_pairs = (k + m + n) ** 2 - (k + m + n)
    mating_dict = { 
            "kk": (1, k * (k-1)),
            "km": (1, k * m),
            "kn": (1, k * n),
            "mk": (1, m * k),
            "mm": (0.75, m * (m-1)),
            "mn": (0.5, m * n),
            "nk": (1, n * k),
            "nm": (0.5, n * m),
            "nn": (0, n * (n-1)), #  superfluo
    }

    good_pairs = 0    
    pairs_sum = 0
    for k, v in mating_dict.items():
            prob = v[0]
            pairs = v[1]
            good_pairs += pairs * prob
            pairs_sum += v[1]
    
    return good_pairs / total_pairs

def prot(inputs):
    ''' Ex. 9: Translating RNA into Protein '''

    rnaString = inputs[0]
    return rna_to_protein_translation(rnaString)

def subs(inputs):
    ''' Ex. 10: Finding a Motif in DNA '''
    
    dna1 = inputs[0]
    dna2 = inputs[1]
    locations = finding_motifs_locations(dna1, dna2)
    return " ".join(str(l) for l in locations)


def cons(inputs):
    ''' Ex. 11: Consensus and Profile '''
    
    datafile = inputs[0]
    genome_dict = read_fast_file(datafile)
    dna_len = len(next(iter(genome_dict.values())))
    
    A_count = [0] * dna_len
    C_count = [0] * dna_len
    G_count = [0] * dna_len
    T_count = [0] * dna_len
    for v in genome_dict.values():
        for idx, nuc in enumerate(v):
            if nuc == 'A':
                A_count[idx] += 1
            elif nuc == 'C':
                C_count[idx] += 1
            elif nuc == 'G':
                G_count[idx] += 1
            elif nuc == 'T':
                T_count[idx] += 1

    dna_consensus = ""
    for idx in range(dna_len):
        candidate = 'A'
        count = A_count[idx]
        if C_count[idx] > count:
            candidate = 'C'
            count = C_count[idx]
        if G_count[idx] > count:
            candidate = 'G'
            count = G_count[idx]
        if T_count[idx] > count:
            candidate = 'T'
        dna_consensus += candidate
            
    out = f'{dna_consensus}\n'
    out += f'A: {" ".join(str(x) for x in A_profile)}\n'
    out += f'C: {" ".join(str(x) for x in C_profile)}\n'
    out += f'G: {" ".join(str(x) for x in G_profile)}\n'
    out += f'T: {" ".join(str(x) for x in T_profile)}\n'
    return out


def grph(inputs):
    ''' Ex. 12: Overlap Graphs '''
    
    datafile = inputs[0]
    genome_dict = read_fast_file(datafile)
    reverse_genome_dict = {k: v for v, k in genome_dict.items()}
    
    res = []
    for k1 in reverse_genome_dict.keys():
        for k2 in reverse_genome_dict.keys():
            if k1 == k2:
                continue
            head = k2[0:3]
            tail = k1[-3:]
            if head == tail:
                res.append(reverse_genome_dict[k1] + " " + reverse_genome_dict[k2])

              
    out = ""
    for item in res:
        out += f'{item}\n'
            
    return out

def iev(inputs):
    ''' Ex. 13: Calculating Expected Offspring '''
    
    population_str = inputs[0]
    populations = list(map(int, population_str.split()))
    # genotypes:
    #        AA-AA, AA-Aa, AA-aa, Aa-Aa, Aa-aa, aa-aa
    probs = [1.0,   1.0,   1.0,   0.75,   0.5,  0]
    
    result = 0
    for pop, prob in zip(populations, probs):
        result += prob * pop
    
    offsprings_per_couple = 2
    return result * offsprings_per_couple

def lcsm(inputs):
    ''' Ex. 14: Finding a Shared Motif '''
    
    datafile = inputs[0]
    genome_dict = read_fast_file(datafile)
    
    first_value = next(iter(genome_dict.values()))
    for motif_len in range(len(first_value)+1, 1, -1):
        for i in range(len(first_value)-motif_len+1):
            candidate = first_value[i: i+motif_len]
            occurrences = 0
            for v in genome_dict.values():
                if (candidate in v):
                    occurrences += 1
                else: # senza questo else fnziona ma ci mette due minuti anziche due secondi.
                    break
            if occurrences == len(genome_dict.items()):
                return candidate
            
    return "no shared motif"

def lia(inputs):
    ''' Ex. 15: Indipendent Alleles '''
    
    k = inputs[0]
    n = inputs[1]
    rounds = inputs[2] # 1000000 to get good approximation 
    
    offspring = "AaBb"
    partner = "AaBb"
    
    good = 0
    
    for i in range(rounds):
        ok_offsprings = 0
        for j in range(2 ** k):
#            offspring = mate2(offspring, partner)
#            offspring = mate2(offspring, partner)
            male = offspring
            female = partner
            offspring = male[random.randint(0,1)] + female[random.randint(0,1)] + male[random.randint(2,3)] + female[random.randint(2,3)] 
            if offspring == "AaBb":
                ok_offsprings += 1
            elif offspring == "aABb":
                ok_offsprings += 1
            elif offspring == "AabB":
                ok_offsprings += 1
            elif offspring == "aAbB":
                ok_offsprings += 1
            
        if ok_offsprings >= n:
            good += 1
        
    return round((good / rounds), 4)

def mprt(inputs):
    ''' Ex. 16: Finding a Protein Motif '''
    
    datafile = inputs[0]
    proteins = []
    with open(datafile, 'r') as f:
        for line in f.readlines():
            proteins.append(line.strip().split("_")[0])
            
            
    fastafile = datafile.split(".")[0]+".fasta"
    protein_database_url = "https://rest.uniprot.org/uniprotkb/PROTEIN.fasta"
    with open(fastafile, "w") as f:
        for protein in proteins:
            url = protein_database_url.replace("PROTEIN", protein)
            response = requests.get(url)
                  
            if response.status_code == 200:
                f.write(response.text)
            else:
                return f"Errore nella richiesta: {response.status_code}"
            
    # N-glycosylation motif is written as N{P}[ST]{P}.
    N_glycosylation_pattern_len = 4

    protein_dict = read_fast_file(fastafile)
    motif_dict = {}
    
    for k, v in protein_dict.items():
        motif_dict[k] = []
        for i in range(len(v)-N_glycosylation_pattern_len+1):
            sliding_window = v[i:i+N_glycosylation_pattern_len]
            if "P" in sliding_window:
                continue
            if sliding_window[0] == "N" and sliding_window[2] == "S":
                motif_dict[k].append(i+1)
            if sliding_window[0] == "N" and sliding_window[2] == "T":
                motif_dict[k].append(i+1)

    retval = ""
    for k in motif_dict.keys():
        if motif_dict[k] == []:
            continue
        protein_name = k.split("|")[1]
        motif_locations = ' '.join(str(x) for x in motif_dict[k])
        retval += f"{protein_name}\n{motif_locations}\n"
    return retval

def mrna(inputs):
    ''' Ex. 17: Inferring mRNA from Protein '''
    
    proteinString = inputs[0]
    
    reverse_RNA_codon_table = {
        "F": ["UUU", "UUC"],    
        "L": ["CUU", "CUC", "UUA", "UUG", "CUA", "CUG"],    
        "I": ["AUU", "AUC", "AUA"],    
        "V": ["GUU", "GUC", "GUA", "GUG" ],    
        "M": ["AUG" ],    
        "S": ["UCU",  "UCC", "UCA", "UCG", "AGU",  "AGC" ],    
        "P": ["CCU",  "CCC", "CCA", "CCG" ],    
        "T": ["ACU",  "ACC", "ACA", "ACG" ],    
        "A": ["GCU",  "GCC", "GCA", "GCG" ],    
        "Y": ["UAU",  "UAC" ],    
        "H": ["CAU",  "CAC" ],    
        "N": ["AAU",  "AAC" ],    
        "D": ["GAU",  "GAC" ],    
        "Q": ["CAA",  "CAG" ],    
        "K": ["AAA",  "AAG" ],    
        "E": ["GAA",  "GAG" ],    
        "C": ["UGU",  "UGC" ],    
        "R": ["CGU",  "CGC", "CGA", "AGA", "CGG", "AGG" ],    
        "G": ["GGU",  "GGC", "GGA", "GGG" ],    
        "W": ["UGG" ],    
        "Stop": ["UAA",  "UAG", "UGA" ],    
    }
    
    count = 1
    for c in proteinString:
        count *= len(reverse_RNA_codon_table[c])
    count *= len(reverse_RNA_codon_table["Stop"])

    return count % 1000000

def orf(inputs):
    ''' Ex. 18: Open Reading Frames '''
    
    datafile = inputs[0]
    genome_dict = read_fast_file(datafile)
    dnaString = next(iter(genome_dict.values()))
    
    DNA_codon_table = {
        "TTT": "F",      "CTT": "L",      "ATT": "I",      "GTT": "V",
        "TTC": "F",      "CTC": "L",      "ATC": "I",      "GTC": "V",
        "TTA": "L",      "CTA": "L",      "ATA": "I",      "GTA": "V",
        "TTG": "L",      "CTG": "L",      "ATG": "M",      "GTG": "V",
        "TCT": "S",      "CCT": "P",      "ACT": "T",      "GCT": "A",
        "TCC": "S",      "CCC": "P",      "ACC": "T",      "GCC": "A",
        "TCA": "S",      "CCA": "P",      "ACA": "T",      "GCA": "A",
        "TCG": "S",      "CCG": "P",      "ACG": "T",      "GCG": "A",
        "TAT": "Y",      "CAT": "H",      "AAT": "N",      "GAT": "D",
        "TAC": "Y",      "CAC": "H",      "AAC": "N",      "GAC": "D",
        "TAA": "Stop",   "CAA": "Q",      "AAA": "K",      "GAA": "E",
        "TAG": "Stop",   "CAG": "Q",      "AAG": "K",      "GAG": "E",
        "TGT": "C",      "CGT": "R",      "AGT": "S",      "GGT": "G",
        "TGC": "C",      "CGC": "R",      "AGC": "S",      "GGC": "G",
        "TGA": "Stop",   "CGA": "R",      "AGA": "R",      "GGA": "G",
        "TGG": "W",      "CGG": "R",      "AGG": "R",      "GGG": "G", 
    }

    startCodon = "ATG"
#    strands = [dnaString,                           
#               dnaString[1:],                       
#               dnaString[2:],                       
#               reverse_complement(dnaString),       
#               reverse_complement(dnaString)[1:],   
#               reverse_complement(dnaString)[2:]]   
    strands = [dnaString, reverse_complement(dnaString)]   
    
    proteins = set() 
    startCodon = "ATG"
    
    for dnaString in strands:
        locations = finding_motifs_locations(dnaString, startCodon)
        for loc in locations:
            codingSection = True
            protein = ""
            codon = ""
            for nuc in dnaString[loc-1:]:
                codon += nuc
                if len(codon) == 3:
                
                    aminoacid = DNA_codon_table[codon]
                
                    if aminoacid == "Stop":
                        codingSection = False
                        break
                
                    protein += aminoacid
                    codon = ""
            # se codingSection e' true significa che e' finita la stringa prima di incontrare un codone di stop e allora non vale.
            if codingSection == False and len(protein) > 0:
                proteins.add(protein)
        
    return '\n'.join(proteins)

def perm(inputs):
    ''' Ex. 19: Enumerating Gene Orders '''
    
    n = inputs[0]
    dataset = [x for x in range(1, n+1)]

    perms = permutations(dataset)
    
    result = f'{len(perms)}\n'
    for p in perms:
        result += f'{" ".join(str(x) for x in p)}\n'
    return result

def prtm(inputs):
    ''' Ex. 20: Calculating Protein Mass '''
    
    proteinString = inputs[0]
    Aminoacid_Monoisotopic_Mass_Table  = {
        'A':   71.03711,
        'C':   103.00919,
        'D':   115.02694,
        'E':   129.04259,
        'F':   147.06841,
        'G':   57.02146,
        'H':   137.05891,
        'I':   113.08406,
        'K':   128.09496,
        'L':   113.08406,
        'M':   131.04049,
        'N':   114.04293,
        'P':   97.05276,
        'Q':   128.05858,
        'R':   156.10111,
        'S':   87.03203,
        'T':   101.04768,
        'V':   99.06841,
        'W':   186.07931,
        'Y':   163.06333 
        
    }

    mass = 0.0
    for a in proteinString:
        mass += Aminoacid_Monoisotopic_Mass_Table[a]
    
    return str(mass)

def revp(inputs):
    ''' Ex. 21: Locating Restriction Sites '''
    
    datafile = inputs[0]
    genome_dict = read_fast_file(datafile)
    dnaString = next(iter(genome_dict.values()))
#    reverseComplementDnaString = reverse_complement(dnaString)
#    print ('!!!', dnaString)
#    print ('!!!', reverseComplementDnaString)
    
    output = ""
    for length in range(4, 13):
        for i in range(len(dnaString)-length+1):
            if dnaString[i:i+length] == reverse_complement(dnaString[i:i+length]):
                output += f'{i+1} {length}\n'
        
    return output

def splc(inputs):
    ''' Ex. 22: RNA Splicing '''
    
    datafile = inputs[0]
    genome_dict = read_fast_file(datafile)

#    dnaString = "" 
    itr = iter(genome_dict.values())
    dnaString = next(itr)

#    for dna in genome_dict.values():
    for dna in itr:
        intron = dna
        dnaString = dnaString.replace(intron, "")
            
    rnaString = dna_to_rna_transcription(dnaString)
    proteinString = rna_to_protein_translation(rnaString)

    return proteinString

#def lexf(alphabet, n):
def lexf(inputs):
    ''' Ex. 23: Enumerating k-mers lexicographically '''

    alphabet = inputs[0]
    n = inputs[1]
    
    words = combinations(alphabet, n)
    words.sort()
    
    output = ""
    for w in words:
        output += f'{w}\n'
        
    return output
#
# MAIN
#
            
def run (func, inputs, fout):
    print ()
    print (func.__doc__)
    start = time.time()
    out = func(inputs)
    end = time.time()
    print (f"execution time in seconds: {end-start}")
    
    fout.write (func.__doc__)
    fout.write('\n\n')
    for i in inputs:
        fout.write(f'{i}\n')
    fout.write(f'\n{out}\n')
    fout.write (f"execution time in seconds: {end-start}\n")
    fout.write('\n')

problems = [
        (dna, ["CATGCGAGACATTATACACTATGGCTTGGCAGGCGAAGAATATTTCTTGGGATTTCGGACGACCACATTTCCGCCACACACGCCGCGTTGAAGCGTCCTCACGTCACGCCGTTACATTCGTATTCGCTCTAAGCGCCTCCATCACAACCTGTAATACTCTATGAGGGATCAAACCAGGTGCTAACCAAAGAACCAATCTTGCACAGCCGTGTAGGTGGTTCGTGGGAATTACCCGGAAACAGCCTAGAAGAGCATAACCACGTATCGTCGCGAACTGTGTCCATTTTCGTCGCTCAACCAAACACTACTTCGTCGAACTTGAGCGGTGCGACGGCCCTATAAGTACCTTGTATGCCGCTAGGAAGATACCGAAGATCGAAACAGTTATCGGGAGGCAACTGTGTCGTTCCTTACATGTGAGAAAGCACCCCGGAGGGGTGTACGCATATCATGGCCATCTGCGGGGCGAATTGATCTTTAGACCCCGCTTACCCCACGTCGCTTTCCGTCCTTCTTCATAAGACCCCTAAGGGTATGTCCGGTTACAGTTTACGCCACTTCTGCTCGTCTCGATAGTAAGTCTAGCGTCGCATGAGAAAAAGACCTCCGCCGGTACAAATGCATCTAAGCCAACGCGTAAGCACCAGAGAGTTTAATCCGTCTCCGGGCTCTCGAAGCTATTAGTGCCGCGCGGGCATTTAACAGTCAGTAATAGCTCACCCCGCATTAGATGAAGTATGTCACCTCTAACGGACTTCGCATCTCTTGTGTTGTCCAGACTACAGACACTCTAGACAGAAGCCCCTCTGGCGGGCTTGGTGCAGCGCTGGAGTC"]),
        (rna, ["CCCAACAGGCATGTGCGATGAATTATGGTGGCAGGAGCCATTAATAACATCGCTGTGGCCCAACCGGGATGTTGAGAGTTCAACCGATTTCGGCAAAACAAAGACACAGACGAGTTTTGTTTGGGAGGTAGAGCGAGAAGCCCCCATGCCGGATCCATCACCCGGTCTGTAACTTTTTAGGATAGGCGGGCGTGGTCTCCGCATTATCATTCAATCGCGGGTGCCGTATCTCGCCGTCGTTGCATCCCTTACAGCGGGACCAATACACGAACCAGTCCAATCAGGCTTGCTTGATACGCAAAATGTACAATCTATAAATTCGGCTACTAGCATAGCCGAGCCCCCGTAATGGCCTTATACCGCTGGAACGTTCATCTCGAGGGAGGGCCGTGCCACAAACCCGCGGAGCGGTGGCCGTAGATTATACTAGAACTAAAATACATCCTCACTACGGGTGTCGTGGACACCAAACTGAAGGTTGTTGAATACGCTTCCGGAGTAGGGTTCACTATACCTGGGCGAACATCAGCCCGAGCATTGCCACCAATCAAACTAACTCAAAATGACTACTATGTTAGCCTCCGGCGAAGGGGAGTCATTTTCCAATCCTGAAGATTTCCCCGCCCATCCTCGCTATTTTCTCATATCTCAAGAATCCCATGCTTTTTAAATGCCTATGAGAGTGTGTAGGGTCCCTTCTTTATCCTATAGTATCGGCTCCACGGTGACCATGCATTGAAGAATTATTAATGATTCACGGCGCCCATATAAGTCACGTGGCGCGCCCTTCTTGGTTTCATACGCTCCTCGCGCTTGTTTGAGAAAGAAGCAAGTCAGAATTCAGTATATGTTTACAGTCGTGGCGCAGGTACTTGCAACTCGGGTAGGCTACGCTGCCGCGTTCGAAGACACAAATCTACTGGTTACCTATCTGCAAACCAATTGTTAGGGTAGACAGCCGAAACTAGTCTAACCTCAGTAAATAG"]),
        (revc, ["AAAACCCGGT"]),
        (fib, [36, 3]),
        (fibd, [96, 18]),
        (gc, ["gc_dataset.txt"]),
        (hamm, ["ATGTACTGGTCAAAGTGTAGTTTACCTATCCTCAGTGACTGAAGGGCTATCGCGGTGTTGATTCAGTGGCATGCGGGCAGCGTAAGGACACAGATATTAAAATCGGGGAATCGTGTATGTGATAAAGGAACCGAGGGAATTCCAGTCAGCCGGCTCAAACGCAATTTGGTGGGCTTTGTGTCAAAGTCATAGTGCAGTGCGGTGCACGCGTTTAGACTATATGCCCTCTGAACTGTTAGGTTTGAAGAAGACGGGACGCGGAGTGAGCGAACGCTTTTAAAGATTGCCGTCGGTCCTCGGCGGGCCATCTGATCTGAAACCTTCTCAGGGGCCATCCTAGGCCCAAGACGGTCCACCGCTAACTAAGAGATAGTGCGATCGCGCTGTAAATGCGTATCTAGTGTGGAGATTGAGGCAGGGATCCCCCATTACAACCAGGGTCGCCCTGCGTCCACGACGCCTGGGCTACCGTTCAATGTGCACTCTGACCGGGAGCGTCCCTCTCGTGAGGCTAAATTCAGTTCTAATCGGTAGGGGAGAGAGTACATGTTTCGAAATCAGATGTACGACTTATTAAGGTCCTCTCTAATCCGTAGCCACACCAAAGTATTCGCCGATTAGGAACGGCAATCGTAAGACATTGTACTGCCCCCGTGCTGGTTGTCGCGTATAATGGCGCATATCGCGACACTGCCCTTATATAGCCATACACGAACGGTCCAAGTTTTAACAGAACCGACGTTGCTCTCTAAATTAGTGCTAATGGAGAGTAAGAACGAAGAACGAAGCTCTTTCCGCGAGAATATGTGAAAGCATCAGTCATCTAAGAACCGTTAGTGGTAGCGAAGTCTGCAAGCCTTCGGAAGTTCTCCAGATGTCGGCCCTATGCTCCACAAACGCGACTACGCCTGTGCAACTAAACCAGTCGG", "TAGTACCGATCAAGATAGGGTTTTTACATCGTCAGTCGATGCGGTCTTATGCCCATTTATGCTGAGTTTCCCAGCGGGAGATACTGGATAGAGCTATTAACTTCTCGGAAGCGTTGATGTGACCCAGCGGATTCGCGATCTCGAGGCTCTCCTCTCAGCCTCTTAGTGGTGCGAGCCTCAGTACATCGGGTAAACGGTCTGCGGCCCGCGTTTTGTCGATGTGGCCGTGGAAAGGATCCGTTTGTCTTAGACGGAAGGTTGATCTACCGGACGGCATTCAGGGTAATGCTTAATTTTCTGCTGATATTACCCAGTGTCACCGACACAAGAGCTTTCCTAGCCCCAAGACGTTTGTACCTTAACCACGTGTATGTATTAGCCTGCCGTAGTTTGGAATGAGTTGTATAGCAAGAGGCAAGTGTCCTCCACGACCAACTGGTGCCCCTGACGGCCAGGAACAATTTTGTTCAGCGCCGTATGGTCTCTGATTACCAGTTTGCGCGTCGTATGCAGAAGCACCAACTGACGTCGTGACATAGAGAGTATTGGTGTCTGAACGTGATGGAGTGATTCATGTGTATCCGTCTCTAGAGCTCGTCCAACATATCATCCGTCGATTAATGATAGCACAGTGCACCGAGAGTATACCCCCCGTACAAGGTTTGGTATTTAAGCGAGCATGTCCACAGAACGCACATAGGCACCCCAACTCAGCCGACCCAGGTTTCAAATTACGCGGACTTCCTTTACTCGTGTGTATTGTTGGACATGTAAACCATACAACCAACACCACTGTGCAACAATATGAGCAACTACCGATGTGCCCGTACTAACGCGAGCGGGAATAGTCGCCGAGGATTGACCAGTACTCAAGTTGACGGCTCTATACTATACAACGGCGACTACGCCAGGATAACCAAAGCTTTCAT"]),
        (iprb, [17, 16, 15]),
        (prot, ["AUGUGUGUCCCUUUAACAUCUAACAGAAUGUCCAUUUGGAUUGUGCAAUUAUCACCGUCGGGGCGCCCAGACCGUUCCUCAUUCCAAUGUGGCGAACGACCGGACAUCAAGACGCCGUGGCAUCAUCUGCACUUGUUAGCGAAAGAUCGUAAGUAUCUGGGAAAGCUGCAAUCCAUCAGUGGUGCUCACAGCCCCCCACACGGUAUGUGCAGGGUCCCAUACGCUCCCUGUGUAUGCGACUUCGCACUUAGGCCUCGAGUAGGACUAGGUCAAGUGUGGGAUGCCGUAUUGCACAUAUAUGUACGGGAGGUGUAUGCGAGAGGAAAUGAAUAUGUUCUUAUAUACUUUAGGGCCUCUACCCAUCUACAUUCCCUUUCGCUGACUAUUCUGGCUCCUUACCUCGGAUCGAUUGUCGAAUUCGUCUCUAUUUGCGCAGUUCAAGGUCUAAAAAAGCGUCAGGUUGACCCUGACGUCUAUUCACACUUGCAUUCAAGCCCUGUAUGCGGAUACUUACCUCUAGACUGGAACCUUCAAGGUAAAACUCGACCAAUUAAAAUCCCAGGAUCUACACACGGUGACGUCCUCUUGCAUACCACGCAGUCCGCAGGAGUAGCCCUUAAUGGUGUUAAUGAAACAGACAAUCUUCUCAUGCCUUUGCCUCAAUUAUCAGUAGGAUAUCCAGGAAAUCUGAGCGCGGUACCCCUACGUACUAGAAGCUCGAUGCUCCUAAACAUCCGAAGCUAUCGGCACCGGAGUAAGAGUAGACAACGAGGAACCAGAGAAUUUACGACAUGCCCGCAUACCUAUCAGGCCCGUUCUUCGGUCAGAGCGGAAAGGCGCGGACAUAACAGGCCUGGGCAUUUCCCCAGGACACUACUGGCGAUUCCAAGAGCGGACGCCAAUCGGCCUACACCGCCGUUCUGUAAAGGCGACCAACUUAGAACAUGUCUUAAGCAAGCAGCGGCCUUCAGUUCUGCGCGCGUGUUUCAAAAAGCGGAGUACGCAGAAGGUGGGAAUACGCUUCGUACGGUUAUAUUUUCAUACAUCCCUCCGACAAGUGUUGUGGUGUUAACUACCUGUCUCUUAAGGACAACUUCAGUUUCCAGUCGGAGUGGAGAGCGUAGUCCGCCCAGUGUCCCUGCUCCCGUUACUGAUAACCUCUCCCACAGGGCGAAACGGAGGUGCGGCGUUACUUCCACUCCCACGAUGCGCGGGGCCCCGGGACGAAAAACAUACGCCGUUUAUUGCGUCGACAGUUCCCUAUUCUGCCUGUGGUGCAUAAAACCGAGCACGCAAAGUCACCUAAACUUGCUGGAGCCCAUCCAGGGAUUUUCGAACCUUGGUUCUGAGGAGUAUCUGCGUAACGGGUAUGUGCUUGUACGGCUUCGGUACGGCGACUCGUUACAUCUGGUAACUGCGCCUAGCCUUCGUAGUGUAGCAGACUGUUGGAGCUAUAGCAAUCUCCACGAAGUAAACACUGCGCGUGGCCGGCUAGUCGCGCUCGCCUCCAAUAGACUAGAUUACGCCGGCGGACCGUUAUUAUACAGACAUGAGCGAUUUCACGAGGCCAUCAUGCGGAGAGAGAUGACGCUCCUUUAUCACCAGUGGUGGGAAUAUACAAUUACUGAUAAGCCCGGAACGGCGAUGAAAUACUUCGUCAGGAAGAAGCGAUGGCGUGCUGCCGAACGUCGGAAUAAGGUGCUGGGUUGCUAUCAUUUAGGUGACCAUAUAUAUAUUAAAACUAAAUACCGCCAUUCCAGGUCCAGUAGGGGCGGCGUCCGGAUGGCGUAUCAGUCAAAUUGGGCAUACACUCAGCGGCAUCAAACUAAGCCGCUUGCGUUGUACAAACCUUCGACAGAGGACCGUCGGAUCGACAGAACGCGACAGCCGUGGGAUCGUUCACCAAGAGGAUGUAGGCGCUAUAUUUACAGGGGCAACGAACCCCUGAACACUGGUAACAUAUGCCUAUUUAGCACCUUUAUGCAUGACCUCCAUGCACUUAAUUCUUAUGGGCGGGGGGCCCUAGAGAACCACUCGUGUGCAAUAUUGGCUCUACACAUGCGAGAGCAGGUGGCCUCCAUGGCGCCUCAGACCAUAGUCGCACCCAUCAACAAUGUCGUAACGUGUUCGGAGACCAUAUUAGACCAUAAACCAACUUGCCGAUGGCCAGACAUUUCAUUUCCGCGACGGAGCGGAUUCUAUCUCAUUUUGUCCAAUGGCUCCUCAGUUAGGAUAUGGUUGCUCCUCCGCACAUUUCAUCUUACUUUGGGGCAUGUUGUCGUCUGCGAGAGUUUUCCGCGAGCGUUGACUUCAAGUGCGUGUCCAGCGCUGCUGGAUGGGGGUAGCCGUAAUCUGGCCCCGUCCUUGUUCGCUCCGAGUGCCGUUGCUUAUCCCGUGUACUCUAUCAACCUACCUGGGCGCAAUUGGACAACCGCAACCAGUUGUUCAGUACGCAUAACUGCCUACAGCUAUGCUUCAUCUGGCUUAGAGAGGCGUUUGGUCAUGUUUCACGACUGUCGACCGAGUGCUCGUACUCUCUUGUCCCGCCACCUUAAGGCUAGUUUUGGGCUAGUCGCGGUUGGUACGCCACUCGGGAAACGCCCCAGAUGUGCCGGCCGCGCACCUCGUACCUGCCCUUGUACUCUUGUAACACUAGCAAAGCCGAUGGUGUUGCCUUUUAUACUGUGGCCCACCGCGGCCACCGCGUCGAGUUUCCGUCCUUUGCCUCAACGGAAAUUUCAAGAGUAUGAUGAAUACAUGUGCCCGCCACUAAGGCCCACAGAGCUACGACACGUGCUUAGAUCCGACUCUGGCCCGGUCCCUGAAUUGGAUGUGGUAGCUUUGGUGGCGAUUACAGUGAAGCUAACUCUAGAAUCGGCACCUACGCAUUCCCGCAGGUAUCCUCAAACCAGUAAUGGCCCGGUUAGGUUUGAAAGGGUCAAAUCUGGCGCUAGAGAACGCGCCUCAAAAAAUAAUACACUUUUCCGAUUCGACCAAAGAACGAUUCCGAAACCGUGGCACAAUAAUGCGCUGUCGUGCCCCGUUACUGCUCUUCCGGCACUCAUGGGCACCAGUUAUAGACACAUCGCCUACUCUUCUACGAGCCAUCGGUGCCUACUGUCGAGAGGUCAGCCCCCGGGCGCAAUAUCGCAUCCGCAUCUCACUUCACUUUCUCUAGCAAUAUGCUGUCAACGUUGUAAAGAAGGACCUGUUGCCGUCUCCGGUAUGCAAUGUACCCCUCAGGCAGUGCCAUGCCUGGGUUAUAAUCCACCGUGGCUAUUAUCUGGUGCCGGCCCCAUAUCGUUCCGCACUUACAACGUGAAAUCUCGUUCCGUUUACGCCUUCCUGAUUUUCUGCGACAGACACCACGUCACCCUGAUCCCGGAAAUCGAAGAAACCUUAUGCCAGUGGGAUUUCGCGUGGGUAGACACACCAGCCACCCCUGCAACUUUUUACAAUACUCUAUUACGGGCUCGUAGAUGCCUGGAACCGCCUUUUCCAAGACCGGGGGUGCAUUACUCAUCCAAAGGAUCGCCCAAUUCGCGCCCGUAUGUAUCAGUUGCCUUGUUGCAACGGGUUCUUAUCUUUCUCAACUUUGAGGCACCGCUGCCACCCACGUAUCUUAGUGCGAACAACCAGCUUACUAUGCUCAGGCUCGGUUUUGCGACAUUUUCCUUGGCCACUUAUUGUGCCCCCACGCUGCCGUUAGUAUACAUGACGAAUCGCCCGUUAGCCCUGCCGGGAGAUCCUGGAGGCUGUCACACGCGUAAUCGUUGCGAUGAAGGUCUAAGAAGAAUCUGCCAAUCCUCAAGACCUGCAUCGAUGCUGUGUACGUAUUAUCUAUUGAACCUGUUUCCCCCCUGGCGCAGUUCUGCCGACCUUGUGGUUGCUACUACCCUUCGAAUAUGUCAAGAGUCCCCGUUUACUGUGUGUCUAGAGCUUAGUUCAAGGGCGGAACCGGUUUACGCGUCUCUUGUGGAUGCUUUAUGUGGCAACGGUACCUCCCCCGUGCUGAUGUUCUCUGAGUUACCGGACGCGAUCCUGAAACCUAACCCAGAUCAGACCCGACGCUUGGCAGUGGUUUGGAGUGCUCUGUUCCAAGAGCUCUGUUGCACGCUUCAGAUGUCCGUCGGCUCAGACGUGGACCCUUGUGAAAUCGUUGCAAAUAAACCAAAGAGCAUUACGGCGCACGAACGUGAGUUCAACUAUAUAAUUAGUCGGUGGAAUGACGCCCUGUUUUACUCACUUUUUCCUCCACUGAUCAGUGGCUAUCCGGGCGGCUUGUCUAAACCAGCUUCGCCCCCUUUCUUGAAUAGCCACCGACGAUUGACUUCUUGCAUGGCAAAGGGUGCCGUUUUCCUAGUGUAUGCUCCGAGCGCAAACCCUGGUCGAGGCUAUUUACCGGGCAUAGACCUUCAGAGACGUGUCAUAGUAAGGAGUAACGCCAUCACAGUUCGGAACCCAGGAAUGCCAUUGGCAAGGGAUGUUCUCCUGUUCUGGUCGUUCGAUAAGUCUACUGCUACGUCGCUGGUUCUCAGGGGCAAUACGCUGGUGCCAAUUAAAGUGUCCAAGCAUUGUAUCCCGGUUAUAUCCACAGUUAGUGUGCUGUGUAAAACCAGGCAUUCGACUACACGCGGAAGAGCUAAGUGGUUCUGCAGGGUAGUAUGUGCUGCUAGAUCAGUCCAGUCCGUGGGCCGUCGGCUUGCAGAUCACAGCUCUUCUGAUUGGUUAGCAGAACGAUGGCCUAGACAGCGGCGACCGUUACCCAAGUAUUAUUUUGGACCGAUCAGGCUAUACCGAGCUGCGCCCUCUUACAUUCGUGACUAUGUGUGCAUGCUCGAGGAGGUUAGUUAUAAGGAGGUCCAUAAGACAAGUUCAUCUUCUCACCACAUUUACGGCCAUUAUACCAUGAGUCACAUACCUGCCUUUUGGUUGCAGGGAGCUAUACCCAGAAGUGUCAACCUUGGCGACCUCACGAAUCGUCCGCGUCUAGUUGCGUUCAAAAGGUAUUGCCGCACGCUCCGCCCCUGGAACCGUAUGGAAAUAGAACAAAGGGGCUCUCCCCGUAAGCCGCGCUCAACUCCUCGGGCCCCUCGCGUAGCGCUCAAGUAUGAAUCCGAGUAUCGCUGCGUUGUUGCUUGGAACAAGACCGCCGUGCAAAACCCAACUAUAGGGACCCUAAUCGACGCUAUACGCUUUUACCGCUCAUUGCCACAAGUGAUAAAACAGUCCAUACCGGAGAGGGAGUGCGAACAGAGGCCAAGGGCUGGUCAGUCGUCUCGUUGCAGAACACGAUCAACGAAUGCGCGGGAACUUAGGGGUCCCCACAUUUCGAAGUUCGGUCAUCACGCUGAACUCUAUGCCAAUGUAAUAUUACAGCUCACCGGAGGACGCGUUGAUGUGUUAGCUCUAUUUAAAUUUCCACUCGCGGGGACUAUUAAGGGAUUAGGCCGGGCUGUGGCGCAAUCGCAAUAUCUGGGUGACGUUGGCCAAUUUAUUCGCCCAAUGGACUACUUCUCAUCAACACGCCAAUUCUAUCGUUCGAGAACCAUGGAGGGCCAAGAGGCCGCAAUGGCAAAGAACGCCAGCCAAGACAGCAGGUCUAGGAGGGAGCUAAACGGGAAACAACCAGUGGGGCCUAACUUGUUGGCUCUAAUUAGUUCGUUCCGGCAAAGGGUAACUUCCGGCGUGGAGUGUACAGGAAUCACGCGCCACAGCGCCGGCGCGGAGACAUCAAUUUAUGCCCGUCUCACGGGUACGGGCUUUCGCUCUUUAUUUUAUCCGUUAUUGGAACCAUGCGUCGGAAUAUACUCAAGCCUACAGGGUGGAAUCGUGUUCCGCAGCUCGAUGCGCCCCGGUGUCGACCUAAUACGGACAGAGACACUGCGUACACCCCAGGCACCUAAGGCAUACACAUGCCAAGUACCCCACGCUUGUUAUGAGCCCUGGUUGGGUUACGGACCUUCGUCUCGGCUACGUGCACGCAAUCGAGUCUGCUAUCCAUGCCUACCAACCCCAGGCAGGCGCAGCCCGAGGGUAACAUUCCCAUCAGUGCAGAACCGUUCUGGGCCCAUGGUCUACGAUGCUGUAAUAUACCUAGCCAGUUGGGCACAAUCAUGCCAAGGGUGUAACGUACCGGAUUUCCAAGUCAUAGGAAGUAAAAUGGGGAGCUUUUGUUGGUUCUUUGAAUUGUUAACUCAUGUUUACCAAAGUGGACUUACCGGGUCAACGCGUUAUGACGGCUAUUUAACCCCCCGGUACGCGGCCCCUCUCAGGAAUGGAUCGCUGAAAACAGGCCUACGAGUGAAGGAAGACGUCGUAACGCCGGAGGAUGGACUUUGUAAUCGGGUAACUCUAAUACAUUUCAGAGACGACCAUAAGCUCAGGCUCCUUAAGAUGAGUAGACACAUAGCCGUACAGGGGGUUCAUUCCUUCUGUUUCCAGCUCAGUAAAAUGUACUACUCGGUUCAGCAUGCACCCGCUAAGAGGAGUGGUGGUAGCCAUACUCGGACGGACUACUUAAGCCUUCCGGAUAUUGUUCAACCAACCCGACAAAAGCUUGAUAACGUAAAAAUCUUUAUAACUAGUAACCCUGAUCUUAACGGCUCCGUCUACGGAAAAAGGCGAUACUUCGGAAUGUGGACACGACUACUGUUUGGGAAGACGUGGUUGAACACACUCUACCAAUAUGGAGGUAAACCGUCGACCCAUGUUGAAUUUCUAGGGAGCAAUGGAAGGGACCCGGAUCCCUUGCUAUCUGGUAAGAUGGGGAGAAAAAGCACCUUCGAAUCAUCAAUCGAGUCGUCCUCGGCUCAUGGUAUACCUAUGGUCGGCCCAUGUAGUUCGGCUUUAGCUGUGAAAUUUCCGUACUGGGUGGUGAUAGAUUUAAGUCGCGAAGUAUUCUGGUCACUCAGAGGCCCGCGUAUCGUCGGUAAUGUACGUAAAUCGCACCGAUUUUUCUCAAAUUCCUUAAUACAUGGAUCGUGUCCACCGAUGGCGCUCCUCUCGAUCUCAUAUAUGGCGAUUGGCGGGAACAUGUCAAGCCAGCGGCAGCUCAUGCAUUGUAACAAUCGUGCACCCAAACAAGGUGCGUUAUCCCCGACUACAUCGACAGUCGCUCAGCUACCGAAUGCCCAUGGCCUAUGCGUCGCGGUCUCGACUCCUGUAUACAUCGGUAUGGAUAAGAUGCAGCUGGUCAUAAGUCCCAGUGCGCGUCACAUUAGAUUACUGUUUCACGCCUGUCCCGCCCUAGCUAUUACCCAGUAUACAAGGCUAACGCGCUCCACGCAGCUCAACACCGGGGAGGCAGUAACAACUUACCAUGCAUAUGCGUACUCGACCUCUCUAUGGUGGACUACCGAGCGAUGUAGACUCAAUACGCAAGGGCUCCAACCUUUACCACUCUGUCUGUCUACGCGAGCCUCCAACGCCGCAGAGAGUAUCGGAUCACUAGAAUCAUGGUGCGCGACUACUUCAUGUUCGGCUUGGACUGGGCACACGUACGAAAGUCUUGUCCCAGCCGAAUCGGCAAGUCCCCCGUUAAAACCCUAUCCUCGCACGUCGGUAUAUGCAUGCGCAGGCUGUCCCUAUUAUGCGAACCUUCUUUCGCCGUCGUAUGUGGCGACUAGACGUCGGUUUCGGUUCUCUUUCUUCCUAAUGUCUCUGUUCAGUAUCUUCCAUUGUUGCCCUUCCUUCCUCAUACAGAGUCACAAUUACAUUCGACGUAUUAGCCGUGUAGAGGAUAGUCGUUCAAUCAAUUUGCCAGGGGCCCAAAGCCUUCCUGGGCCCAACGUUGAUCCCCGAGAACUUAAAUAUUGUCCAAUUUAUGUUGUGGACAAGUCGUUGACGCAUACUUUGUCGGACCAAUCAGGCGGUUUAGACAGUGAACGGGCUAGUGGACCGAAGCAUUACAAAUUCGUGCCUAAUAUAGACAAGGCUUGUUUGCAGCUAUUGAAGUGUACUGCACCUCAAGGGAGUGAUAAACGCCUCGGUACUAGGCCAGAUCCUCCAUUCGAUAUAUUCAUCGCGUACCUUCAUAACUAUAUCGUACACAACACACAUAAUUACAGCACACUGCGGCAACAGACUGGAGUUUUACGCUGUAAGCCUCGGAAGCCGGUACACAAUUCCGUAUCGCCCUCCCUGUGGUGGUCGUGUCUGAAGGACGCAUCAACGCUUUAUAUCAGUCCCAACGCAGGGCACUUUGAGUGUGGUAUAACGUUUAUAGAGAAAUCGUGUUCUGAUCAUCCUUUGAUCGGAAGUGGCUCGAAGAUGCGGGUUGGCAGCUGUUCCUUACCAAGCUUUCUAACGACGGAGUUUAUACCGAGAUGGGCAGGUCAAGACGACAGUCGCUUGAAACUAGGACAGUGCAUCUCAGGGUCUUCUACUAUGGCUACGCGCCAGGAAUUCCGGUUAUUAGGAUUUUCGGGCAAUAGAGGGGGUCUCUACAACCUGUACAACAUGUUACCGAAUCGAUCGAGCGCCCGAUCCUUGUGUCGUGAAUUAUCCAGGCAGUGCUCGCCUGCGAUUAGUGGACAUGACCGUAGGGACAAACCUGUUGCCACCACUAAAUUGCAGAAUUACAGUGCAGAUAGCACCGCCUGGCGACUCUCAGGAUGUAAGAUUCUCGACCCAACCCGAAUGUUGGGGGACUCAUUACGCGGCUCCCCGAAUCAGUCCAUAGCCCCCUCAGUCUAUGCGAACCCGAAUGUGGUUAGCGGUAAACUAUUCCCAGCCGGUCAGUUGUAUCACGAGGUUUUUUUAAAUGUUGGAGUUGCUCCUGAAUUCACGACAAUCGGGCGCAACCACGGCGUUGCCGACAUAAAAUCAACCGAUAUUCGAGUCGGCUGGCAGGUUUUUACCGCAAGUAGGUCAGCUUAUAGGCGAGAACAACUCCUCACGCGCUAUCAUUUAGAUACUAAUUACUGCAUGGGCUCGUUGGUGUGCUUACGGCUUAUUUGUUUUCACACGUACACGAUUGACGGCCGUCCCGAGAACUACGAUUUAUUGAACAGGUCCCGUGCACCUGAUGAUAGGCCAUCGGGAUGCGCAAGCGCUAUACAGGCCUUCCACCAUAGGCGUGUGCUCAUUUCUCCUCACUCUAGUAGUCAAUGGAGCUGGCACAACUCCGAAAAGCCUGUUGUUCCGACCGGCGGUCUGGAUCAGCAAAGUGCCUGCCCUCGUCCAGUGCCAGGUCUGGGAACUCAGAGUUGA"]),
        (subs, ["CGTATGAACCGTATGAAATCGTATGAGGCGTATGAAGCCCGTATGAATCCGTCCCGTATGACACGTATGATGTCCCGTATGACGTATGACGTATGACGTATGAAAGCGTATGACGTATGATCCACCGTATGAGACGTATGACGTATGACACGTATGACGTATGACGTATGAGCGTATGATCGTATGAGACGTATGACCCGTATGACGTATGAAGCCTCGTATGAACGTATGAGATCACGTATGACGTATGACAAGGCGTATGAATCGTATGAATACCGCGTATGATGGAGTCGTATGACCGCGTATGAAAGGCTCGTATGAAGCGCGTATGACCGTATGACGTATGACGTATGAAACGTATGACGTATGAGCGTATGATCGTATGACCGGCGTATGAGCCATTTGCGTATGAACGTATGAGCTCTCGTATGAATAACGTATGATGACGTATGAGGTCGTATGACGTATGAAGCGTATGATACGTATGAGTTACGTATGACAGCTTCGCTTCCGTACGTATGATTCCGTATGAGATCTCCGTATGACGTGTCGTATGAGCGTATGACACTCATAGCGTATGATCGTATGACGTAATCGTATGACACGTATGACGTATGACTCGTATGACGTATGACTCGTATGATCGTATGACGTATGAGCCGTATGACCGTATGACCGTATGACCCGTATGAACCGTATGACACTTACGTATGAAACGTATGAGCCCCCGTATGACGTATGAACGTATGAAGCACGTATGAAGAGCCGCGTATGAGCCGCAGTGCGTATGAGCTCGTATGACGTATGAACGTATGAGTGTCCCGTATGAAGAAACGTATGACGTATGACGTATGAGCCGTATGATACTCGTATGA", "CGTATGACG"]),
        (cons, ["revp_dataset.txt"]),
        (grph, ["grph_dataset.txt"]),
        (iev, ["16079 16809 18603 19300 18912 19768"]),
        (lcsm, ["lcsm_dataset.txt"]),
        (lia, [5, 7, 10000]),
        (mprt, ["mprt_dataset.txt"]),
        (mrna, ["MPWIEAQNKAIISYECNLGSTGDGKPIFPFMWLAQNMFYAKWYFGQTWMKNHKGIWISGQCAVYPNQTRPVDCYMCGEARWKRNQAIAKCVNLLCGREHCCISWRNMTVTDRNSMSWPDLASFIIQRHSMPDSSNVDYFICGGHGSIHYALWFDVNPGCSWDLLASYVWSPPLMGVCITCTCVHCGNNGMSEASYLQANTPRVLEGQCMRFNMCCWNLYEDCMRTWIWGYVVKGEILQPVRPDLNGLELFQFSDCRHVYPIMTTLSSLGYNVLSISTLIECLDDGSNFCEVCELEIGAKIWRLLAFPNDVRMCEEFSVMPVSMMRAQTSVFGQGFETPNRQMTFAPFGLAIKFDQFAHMILKNCLIFALKMDMNITPVAPNQMKPWPLDCLIYDQCGIRRMRSISACAELPGDESYASTMHQGIWNHSWPAYMWQENTLDYSHNMRCCQKEEIFAHKIQSPRRGAKWLDKMLLDKDATLKSCENVGCQVMQILNSFQESTDESFSRYVKNWPCIPFNKFHMCCWSRVQMGPNCVSCDSSMYAYSVQTVDFKMLYFTTIQGGHNPISFQMDAHILKWDFPRNESHKEACCNVSPEPDLDHCGGNWYQQPSRVEPEHDTNYPYGMRVEPLPFYRWEDHCNKEMHQPTQEAIYAGLLQLLGVPSCLSFLSCFAMADEPITLYMTHLQYKWCNMCCIFSAQKVNVNHKGEHSKKFGATFAQPLLPRWYGRWMINFSQMQIPIKESIDPMWAGTTQAVNKIPRDICHFIMMGGCGDLGGQTIHTFMARKWWGCAIPNGLLKEASGCWYQMKDHKQKNMLRVKCGADRVSHFNLWTTIGHHLARHGGQIRKLKPGIRNDRNQLGGQMVVIWDVWCTECKCIEKEHPSFCSDERTCGATIKETRWFQMLVFFTFQEWSNDGLSDCTHLPMCTEGQMIQRVFPAIKEMRNHEVLLLTWQMGFECILYVAKLDILVTPTSNFVTSQKMYPQMACRIEHKHQGCNENKQ"]),
        (orf, ["orf_dataset.txt"]),
        (perm, [7]),
        (prtm, ["CIEMFTIMYHSDCAIDKQFPCSDPLWFKYAPHQGNSVDPHSAKRRTYAQHNWVCITPLLWNPKTMRGPRRMNMCVPQATSWINQAFPKPSSSIWFSERSFFKYGEMCADHEAMYTPLIISITHCTRNYFCNWHYPPCKRDIGSVCETRSIALKIAAYYNAVEYYELMCQWKITTEDSFTHRCMKNDRYRWEHCKSSADSRSSPEDCIDMLHQICDTIVVGKWADSKARCYMYVSSCLMICQCFKQGTTMMYMYHQIEEPGSDCYMWNGCVFFPWEFLQEPHNVHEYNSMMNFNFMWYFCMSLYSVAIHEMCPRYEGGDLTTNGLNICHQQHCQKKTVYFMGFKSLVLRCQTFNGPCVTECTGANILHNPLNDGRWCGIAFSAGACFVEGSLCYLDGFVQKEVKETLSRTDCLYDHRMFAMLVSYSFEICKMLWGMDHKLFCARNKFTTWLEGVVMDIMREYLFHLCQFGWSNSSQVHLCGMYDCYIQCLLVVWYFMDIVDYDGNWVSKRVYSNKHCCCYPQAIGVKDYCSLVPGRRLNQNMSEQRMEDYFQHWTAHELWFTPLLTAPLCICYAKTDPGPFNVPEAEDPYWVQYEAGPRGTSTHNGISHLDGEENISQYKQNWFQVAFKRKGMLIFHHNTPNVKERHMLDCGSPANMFQWIKMCPLITITRYGHMDNVTWPASPANAPWWFPLAILEQIYAPMMDTCMCFSTNWILNFDNSPIMFMWDANGPELRFCSLQFPCWPCKHTYNWVYLGSYGCQHGHAKYQFKPSNSGPQATIAKYDDVLCWYAYPKFQCYEQKCFDKKVHNNNFEPTSASFTFNDYFHQTAHKKEIYTDYFYYYNRIGWMTWKFMQCCASHYCWVVNNSMNPVQHMGKLIGAVMIPGELACKRACWKPMRSKNQKMLCMAQCSTNIYARHRPRWNYYTDCMCSYCYSGEDSVFGVTVMDVQYVWPIRERNKRCHFAFFIPCQHG"]),
        (revp, ["revp_dataset.txt"]),
        (splc, ["splc_dataset.txt"]),
        (lexf, ["A B C D E", 4])
        ]

f = open("main.out.txt", "w")
for p in problems:

    function = p[0]
    inputs = p[1]
   
    run(function, inputs, f)
f.close()
        